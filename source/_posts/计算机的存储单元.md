---
title: 计算机的存储单元
toc: true
recommend: 1
uniqueId: 2024-04-28 05:04:53/计算机的存储单元.html
mathJax: false
date: 2024-04-28 13:04:53
thumbnail: https://cdn.jsdelivr.net/gh/gh503/CDN@1.0.0/img/bookcase-3614450_1920.png
tags:
    - '存储单元'
categories:
    - '计算机'
keywords:
    - '编码'
    - '存储单元'
    - '大小端'
    - '编址'
    - '寻址'
---
> 摘要
计算机存储单元的组成，存储空间计算、编址与寻址、数据读写。
<!-- more -->
## 引言
如果直接面对计算机的存储单元显得太枯燥，也不容易理解。很多时候，历史充满着趣味性和合理性，想一想为什么计算机存储单元这么设计，知道背后的故事同时，计算机兴趣更加浓厚，知识也变得印象深刻。

## 计算机存储
### 存储单元
我们知道计算机使用电子元器件电压范围来判断是高是低，或使用磁化物质是否被磁化记录信息，或使用闪存技术记录信息，这些信息也就是我们说的“1”和“0”。一个元器件表示2种状态，一个`bit`由“1”和“0”两种取值。

计算机中规定`8bits`为`1byte`，也就是一个字节。那为什么一个字节不是`7bits`或者`9bits`呢？
历史上确实出现了非`8bits`的定义标准，最终都被筛选淘汰掉了。[为什么计算机的一个存储单元是八位？](https://www.zhihu.com/question/20870588/answer/27391534)

而`Byte`的[历史定义](https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82)，指能够用于编码单个字符所需要的`bit`数量，所以在不同的计算机体系中，`1byte可能不等于8bits`。而当今`1byte=8bits`。

也就是说，我们`1byte`就足以表示单个字符，也即作为存储的最小单元。内存设备也就以`1byte`来作为最小的存储单元操作。

`1 B  = 2^8`种状态（一个存储单元）。每8个`bit`作为一组同时操作，可以表示256个数据或着字符。

### 存储空间计算
`1 KB = 2^10 Bytes = 1024 B`
`1 MB = 2^10 KiloBytes = 1024 KB`
`1 GB = 2^10 MillBytes = 1024 MB`
`1 TB = 2^10 GigaBytes = 1024 GB`

1个`Byte`意味着8个电子元器件，不考虑电路其他元件的话。

### 编码
输入信号经过设计好的电路实现逻辑和算术运算，运算结果也是电子元器件电压状态或者组合电子元器件的电压状态。保持这个元件的状态就是保存了数据。读取输入数据，我们将输入端的元器件状态设置好，然后经过设计好的功能电路，得到计算出来的结果，形成输出数据。

但是，输入和输出数据，是怎么和我们的字符、文字相对应起来的呢？

这里推荐一篇文章，可以帮助我们系统性地理解编码：[字符编码的前世今生——一文读懂字符编码](https://cloud.tencent.com/developer/article/1450938)。

- 我们键盘输入字符，在保存的时候，操作系统会以用户指定或者默认的编码方式查对应编码表将字符编码成二进制数据，并写入存储器保存。
- 输出的结果数据，或者打开保存的文本时，操作系统根据编码方式，查找对应的编码表将二进制数据解码，然后绘制显示在屏幕上。

这里操作系统行为会影响显示，如果没有指明文件编码，比如`Windows`默认会以地区编码（中国-`GBK`，page 936）的形式解码，如果在`Linux`系统（UTF8）或其他系统打开，可能出现乱码。`GBK`以2个字节编码汉字，`UTF8`以3个字节编码汉字，相同内容在存储单元上的大小是不一样的。但是`UTF8`是统一编码，更不容易乱码。

`UTF-8 with BOM`在文档头插入了`0xEF 0xBB 0xBF`的`Unicode`字节顺序标记。如果使用`UTF8`编码，一定要使用`without BOM`的标准编码方式。

[unicode.org](https://home.unicode.org/)

## 地址总线
在读写存储（磁盘、运存等设备）的时候，需要定位到对于的内存存储单元。可以设计一个电路，输入位置编码信息（某种表示状态）可以唯一确定对应的存储单元。
- 1个`bit`有2种组合，可以唯一确定2个存储单元
- 2个`bit`有4种组合，可以唯一确定4个存储单元
- N个`bit`有2^N种组合，可以唯一确定2^N个存储单元

反之，如果内存大小为1 KBytes，就是2^10 Bytes，那么需要10 bits输入信号，也就是10个电子元器件。

假设设计输入有32个电子元器件，那么有2^32种组合，也就是4G个存储单元的空间。

地址总线：`Address Bus`，可以认为是提供了一个这样的电路。如果地址总线宽度为32，则能够唯一确定4G个存储单元。

如果是64位宽度地址总线，可寻址存储单元个数2^64 ，即2^32 * 4G = 2^24 T。

总之，地址总线宽度N决定了支持的存储空间大小（2^N个存储单元）。

### 典型存储单元大小

是实际产品中，存储单元的大小由硬件产品设计决定。
如果定义存储单元大小为`512Bytes`，即使是32位-4字节的地址总线，也能支持`2^32*512Bytes=2TB`存储空间。比如机械磁盘的寻址单元（最小存储单元）,称之为扇区，就是512Bytes。

常见存储设备的存储单元大小：
- 机械磁盘：512Bytes，扇区作为最小存储单元。
- SSD固态磁盘：SSD的最小存储单元是1page，是由一组颗粒组成。每个颗粒（cell）可以是1bit、2bits、3bits甚至4bits，典型的1page是4KB，常提及的4KB对齐就是这么来的，也即最小存储单元是4KB。NTFS默认最小分配单元正好4KB，或者使用4KB的任何整数倍。需要说的是SSD在擦除数据的时候，不是以page为单位，而是以多个page组成的块（Block）为单位。
- U盘：闪存的一种，一般使用建议的最小存储单元，通常是4KB。而且U盘不建议使用NTFS格式文件系统（“日志式”，需要记录详细的读写操作），因为要不断读写比较伤闪存芯片。一般用FAT32或exFAT（支持>4GB的但个文件操作）。
- 运行内存：1Bytes。

### 编址
确定最小存储单元之后，想象将存储设备所有存储单元一字排开，开始给他们依次编号。由了编号也就是地址，我们可以找到对应的存储单元。根据我们地址总线的宽度，可以从0开始编号，直到将所有存储单元编号完成或者超过支持的最大存储空间。

这样，当我们在地址总线输入端设置对应的编号数据（对应电平信号）时，电路直接能唯一确定到对应的存储单元。`CPU`根据命令，经由数据总线读取或者写入对应的数据。通常数据总线和地址总线宽度相同，但不绝对。

![](https://cdn.jsdelivr.net/gh/gh503/CDN@1.0.0/img/girl-583917_1920.jpg)

#### 字 word
字的定义，表示自然的数据单位。在计算机中，表示一次性处理事务的固定长度位组。这个很好理解，我们将一次性处理事务时数据长度定义为字这个概念。

字不是固定长度，由计算机CPU中数据总线宽度决定。如果数据总线宽度32bits，字长32bits；如果数据总线宽度64bits，则字长64bits。而字节长度在不同的计算机中，我们认为都是8bits。

存储单元可以是字、字节，两者没有必然联系。可以根据实际情况进行换算。

不同的编址方式，实际上还是看存储单元大小。
在硬盘或U盘等设备格式化时，可以设定存储单元大小，可以预料到最小存储单元越小，利用率越高，效率越低；而最小存储单元越大，利用率越低，效率反而越高。申请过内存的同学肯定知道，内存空间足够的话，我就不需要再申请了，一次性写入。

### 寻址

#### 数据的高低字节
一个字节=8bits，高低2个字节=16bits，用16进制形式表达`0xABCD`。
我们知道16进制一位需要4bits来表达0~15。也就是2位16进制8bits，1个字节。

这里`AB`为高字节，`CD`字节（10进制1234中，12高位，34地位）。

#### 地址的高地
我们已经按存储单元给存储空间进行编号，每个存储单元都由自己的地址。从0到2^N-1，这里N为地址总线的宽度。
如果将地址换算成16进制的话，就是0x0到0x3FFFFFFFFFFFF（N=32）。

低地址：从0开始，前面的地址
高地址：从0开始，后面的地址，最后的地址最高。两者相对的。

存储单元如果从前往后使用，称之为往高地址方向生长。反之，称之为往低地址方向生长。

#### 存数据

当我们拿到数据时，该怎么存呢？
是优先用高地址还是地地址？
如果一份数据需要用到2个或者多个存储单元时，应该把高字节放到高地址还是低地址？

确实有不同的方案。

- 数据： 0xABCD
- 存储单元：0x1234

第一种方法：我们将数据从左往右存入存储单元种，有点类似字符串顺序处理。称之为“大端模式（Big-endian）”。
即：0xAB -> 0x12
    0xCD -> 0x34

第二种方法：将小的数据放入低地址，将大的数据放入高地址，这种处理方法和我们的逻辑一致。称之为“小端模式（Little-endian）”。
即：0xAB -> 0x34
    0xCD -> 0x12

#### 取数据

当我们取数据的时候，读出来的字节应该怎么恢复为原始数据？
- 存储单元：0x1234
- 存储数据：0xABCD

如果是大端模式：由于是按字符串方式存的，所以取的时候也一样，直接还原为0xABCD
如果是小端模式：由于是按大小高低逻辑方式存的，所以低字节的数据在低位，还原为0xCDAB。不是0xDCBA，因为这里例子存储单元是按字节操作的。

那计算机到底是哪种模式，可以使用程序测试：
1.创建占用2个存储单元的数据并赋值，当然两个存储单元的数值肯定要不同，然后逐个读取
2.如果低位是高字节，是大端；如果低位是低字节，是小端。


参考文章:
无。
